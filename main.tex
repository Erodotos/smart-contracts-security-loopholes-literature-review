%
%                       This is a basic LaTeX Template
%                       for the Informatics Research Review

\documentclass[a4paper,11pt]{article}
% Add local fullpage and head macros
\usepackage{head,fullpage}     
% Add graphicx package with pdf flag (must use pdflatex)
\usepackage[pdftex]{graphicx}  
% Better support for URLs
\usepackage{url}
% Date formating
\usepackage{datetime}
\usepackage{multirow}

\newdateformat{monthyeardate}{%
  \monthname[\THEMONTH] \THEYEAR}

\parindent=0pt          %  Switch off indent of paragraphs 
\parskip=5pt            %  Put 5pt between each paragraph  
\Urlmuskip=0mu plus 1mu %  Better line breaks for URLs


%                       This section generates a title page
%                       Edit only the following three lines
%                       providing your exam number, 
%                       the general field of study you are considering
%                       for your review, and name of IRR tutor

\newcommand{\examnumber}{2187344}
\newcommand{\field}{Detecting Ethereum Smart Contract Security Loopholes}
\newcommand{\supervisor}{Lorenzo Martinico}

\begin{document}
\begin{minipage}[b]{110mm}
        {\Huge\bf School of Informatics
        \vspace*{17mm}}
\end{minipage}
\hfill
\begin{minipage}[t]{40mm}               
        \makebox[40mm]{
        \includegraphics[width=40mm]{crest.png}}
\end{minipage}
\par\noindent
    % Centre Title, and name
\vspace*{2cm}
\begin{center}
        \Large\bf Research Methods In Security, Privacy, and Trust \\
        \Large\bf \field
\end{center}
\vspace*{1.5cm}
\begin{center}
        \bf \examnumber\\
        \monthyeardate\today
\end{center}
\vspace*{5mm}

%
%                       Insert your abstract HERE
%                       
\begin{abstract}

\end{abstract}

\vspace*{1cm}

\vspace*{3cm}
Date: \today

\vfill
{\bf Supervisor:} \supervisor
\newpage

%                                               Through page and setup 
%                                               fancy headings
\setcounter{page}{1}                            % Set page number to 1
\footruleheight{1pt}
\headruleheight{1pt}
\lfoot{\small School of Informatics}
\lhead{Informatics Research Review}
\rhead{- \thepage}
\cfoot{}
\rfoot{Date: \date{\today}}
%

\section{Introduction}

During the predawn of the 21st century, we glimpsed a rapid technological and
economic development that brought us face to face with a new technology called
the blockchain. In recent years, blockchain and foremost cryptocurrencies gained
much attraction due to the high monetary gains, which seem astronomical compared
to traditional stock markets. It is a matter of the fact that this growth has
acted as a catalyst for the technological and research eruption we have been
experiencing lately. By the end of 2021, the total cryptocurrency market
capitalization was 2 Trillion US Dollars[], featuring more than 16000 projects[].
Initially, the blockchain was proposed to facilitate the transfer of value
completely decentralized and trust-framed over a network of peers. This was
Satoshi's Nakamoto Bitcoin[] that came into existence in 2008. Since then, the
research and technological trends have shifted into second-generation
blockchains. Among them, the most dominant is Ethereum[]. Ethereum is a
general-purpose blockchain, providing an open platform for individuals to build
their applications on top of it. Their applications, i.e., Smart Contracts, are
pieces of code that run decentralized on the Ethereum network. This allows
developers to get involved in this new technology, creating an entirely new
industry. Ethereum's ecosystem flared into a broad spectrum of Smart Contract
applications, including, but not limited to, financial apps, games, digital art
and music, digital voting, and patent registration. 

Smart Contracts have balance measured in Ether and persistent private storage.
The Smart Contract's code can manipulate changes in the program's variables and
storage. On Ethereum, Smart Contracts code is in EVM[] (Ethereum Virtual
Machine), a Turing complete stack-based bytecode language spanning 144 OP
codes[]. Nonetheless, developers can define their code in a high-level language
such as Solidity[], compiled to EVM bytecode afterward. A new transaction
invocation can cause the execution of the contract's code by receiving inputs
and producing outputs. Typically, when a user wants to trigger a Smart Contract
needs to create a new transaction and pay some fees[]. Transaction fees depend on
the code being executed on the Ethereum network.

Beyond any doubt, the Ethereum blockchain is used to manage digital assets
reflecting a considerable value. Hence Smart Contracts gained the interest of
malign entities. Numerous attackers perform attacks on the Ethereum
applications, with the ultimate goal of stealing Ether from them. One of the
most severe attacks was the infamous DAO[]. In more detail, in 2016, an
autonomous decentralized organization was founded to direct a venture capital
fund. This organization was formed on the Ethereum blockchain, and over 11000
investors deposited into a Smart Contract over 150 Million US Dollars[]
considering the Ether price back then. Then, an unprecedented attack[] was
performed on that Smart Contract, resulting in 50 Million US Dollars loss.
Another critical incident happened with the Parity Wallet[], where the attack []
led to freezing 150 Million US Dollars, in terms of Ether, impermanently.

Nevertheless, it is typical for any piece of code to have bugs. Likewise, we
expect Smart Contracts to behave in the same way. Potentially, five main reasons
make Smart Contracts vulnerable. We might blame developers for not wholly
understanding the blockchain development stack[smart check]. Also, Solidity is a
relatively new language with many limitations and challenges. Thus, it is hard
for developers to use it[smart check]. We consider blockchain immutability as
another non-helping characteristic. Any application deployed on the Ethereum
network can not be modified, so software fixes are not immediately
doable[contract fuzzer]. A public blockchain allows financially motivated
attackers to use their online pseudonymity to exploit any software bug[smart
check]. Finally, we cannot control the Smart Contract execution environment
since the network runs in a decentralized fashion[smart check]. For this reason,
Smart Contract developers need to detect possible vulnerabilities in their code
before going live. A Smart Contract Auditing tool would benefit both users and
developers. A developer might use the tool to detect any code issues before
deploying the Smart Contract. At the same time, users can utilize the tool to
check if the Smart Contract they are depositing Ether is safe and does behave
maliciously.

Indeed, such tools came into existence in 2016, with the first one being
OYENTE[]. Since then, academic researchers have invested time and effort in
expanding this research field, developing a plethora o tools. Some of them are
general, trying to detect any vulnerability, while some others focus on a few of
them. Also, they employ different analysis techniques, such as Static Analysis,
Dynamic Analysis, Symbolic Execution, Fuzzing, and Machine Learning.
Furthermore, researchers attempted to document and classify many of these
vulnerabilities according to their behavior or functionality.

The contribution of this work is three-fold. Initially, we document and classify
Smart Contract vulnerabilities reported across the most prominent studies. Next,
we present the research trends of developing a Smart Contract vulnerability
framework throughout the years, giving an overview of the techniques used and
directions taken. Finally, we elaborate on the result reliability and
scalability of the most paramount frameworks.

The structure of the following literature review has as follows ...

\section{Methodology}

In this literature review, we explore the most prominent research attempts
towards creating an effective vulnerability detection tool for Ethereum Smart
Contracts. The method used to filter relevant studies comprised both bottom-up
and top-down strategies. Their combination significantly accelerated identifying
adequate quality papers to include in this literature review.

During the bottom-up stage, we sought several papers related to frameworks that
identify Smart Contract vulnerabilities. To achieve that, we employed
trustworthy academic search engines such as \emph{Google Scholar} and \emph{IEEE
Explorer}. We noticed that most of the retrieved writings had a joint primary
related work, which guided us to discover this research topic's essence
paper\cite{luu2016making}. 

Subsequently, we aimed to find any derivative studies related to the paper
arisen in the previous phase. To do so, we used a graph representation
tool\cite{connectedpapers} that links relevant papers. This mechanism allowed us
to identify remarkable research articles rapidly. Afterward, we manually
inspected the search results and included the most reliable in our under
investigation list.

Namely, we collected forty-seven papers, but we only consider nineteen of them
in this literature review. The selection criteria span the context of the
studies and their research contribution. We measure their contribution according
to their citations and release year. According to their publication year,
studies are assigned a weight ranging from 1 to 4. Papers in the span of
2016-2017, 2018, 2019, 2020  receive 1, 2, 4, 8 points, respectively, for each
citation they hold. Using this metric, we evaluate the studies shown in Table
\ref{table:studies}.

\begin{table}[t]
        \begin{center}
            \small
            \begin{tabular}{||p{11cm}|c|c|c|c||}
                \hline
                Study & Year & Cit. & Score & Ref. \\ 
                \hline
                \hline
                Making Smart Contracts Smarter & 2016  & 1445 & 1445 & \cite{luu2016making} \\
                \hline
                A Survey of Attacks on Ethereum Smart Contracts (SoK) & 2017  & 1176 & 1176 & \cite{atzei2017survey} \\
                \hline
                Securify: Practical Security Analysis of Smart Contracts & 2018  & 436 & 872 & \cite{tsankov2018securify} \\
                \hline
                VerX: Safety Verification of Smart Contracts & 2020  & 103 & 824 & \cite{permenev2020verx} \\
                \hline
                ZEUS: Analyzing Safety of Smart Contracts  & 2018  & 399 & 798 & \cite{kalra2018zeus} \\
                \hline
                Finding The Greedy, Prodigal, and Suicidal Contracts at Scale & 2018  & 357 & 714 & \cite{liu2018reguard} \\
                \hline
                SmartCheck: Static Analysis of Ethereum Smart Contracts & 2018  & 291 & 582 & \cite{tikhomirov2018smartcheck} \\
                \hline
                Formal Verification of Smart Contracts & 2016  & 525 & 525 & \cite{bhargavan2016formal} \\
                \hline
                ContractFuzzer:Fuzzing Smart Contracts for Vulnerability Detection & 2018  & 233 & 466 & \cite{jiang2018contractfuzzer} \\
                \hline
                Slither: A Static Analysis Framework For Smart   & 2019  & 109 & 436 & \cite{feist2019slither} \\
                \hline
                MadMax:Surviving Out-of-Gas Conditions in Ethereum Smart Contracts & 2018  & 213 & 426 & \cite{grech2018madmax} \\
                \hline
                Manticore: A User-Friendly Symbolic Execution Framework for Binaries and Smart Contracts  & 2019  & 91 & 364 & \cite{mossberg2019manticore} \\
                \hline
                teether:Gnawing at Ethereum to Automatically Exploit Smart Contracts & 2018  & 173 & 345 & \cite{krupp2018teether} \\
                \hline
                Vandal:A Scalable Security Analysis Framework for Smart Contracts & 2018  & 154 & 308 & \cite{brent2018vandal} \\
                \hline
                ReGuard: Finding Reentrancy Bugs in Smart Contracts & 2018  & 122 & 244 & \cite{liu2018reguard} \\
                \hline
                Ethereum Smart Contracts: Vulnerabilities and their Classifications & 2020  & 12 & 96 & \cite{khan2020ethereum} \\
                \hline
                ETHPLOIT:From Fuzzing to Efficient Exploit Generation against Smart Contracts & 2020  & 10 & 80 & \cite{zhang2020ethploit} \\
                \hline
                GasFuzzer: Fuzzing Ethereum Smart Contract Binaries to Expose Gas-Oriented Exception Security Vulnerabilities & 2020  & 8 & 64 & \cite{ashraf2020gasfuzzer} \\
                \hline
                SoliAudit: Smart Contract Vulnerability Assessment Based on Machine Learning and Fuzz Testing & 2019  & 13 & 52 & \cite{liao2019soliaudit} \\
                \hline
            \end{tabular}
            \label{table:studies}
            \caption{List of papers that are analyzed in this literature review, sorted by their score}
        \end{center}
\end{table}

\section{Literature Review}

\subsection{Smart Contract Attack Surface}

One of the most important aspects of Smart Contract vulnerability detection
tools is understanding and realizing models that precisely describe a
vulnerability. Different authors have unique approaches on how to classify
potential faulty code. For example, according to their overall behavior,
Nikolic et al. [Finding greedy ...] categorize Smart Contract into Greedy,
Prodigal, and Suicidal. Namely, each category represents an abstract
representation of a group of more explicit vulnerabilities. On the other hand,
some other authors prefer to distinguish vulnerabilities based on the domain
they affect. For example, a few studies, like GasFuzzer [gas fuzzer], choose to
examine only gas-oriented vulnerabilities. Subsequently, it is abundantly clear
that there is a broad spectrum of Smart Contract vulnerabilities, and there is
not a single universally accepted classification of them. In 2017 Atzei et al.
[sok] published a survey including the most well-known security pitfalls of the
Ethereum Smart Contracts. In more detail, they report twelve points,
taxonomizing them into three categories (Solidity-Level, EVM-Level, and
Blockchain-Level). Four years and over ten million blocks later, new
vulnerabilities arose. Hence, within the context of this literature review, we
have collected reported vulnerabilities across different studies and present a
thorough list of them, trying to categorize them into seven groups.

We categorize vulnerabilities according to their domain. In the first place, we
noticed that a few frameworks tend to include in their auditing report warnings
related to Smart Contract syntax or related good programming practices. Thus, we
included a category to wrap up all of these suggestions. Furthermore, we have
classes referring to internal, external, and arithmetic bugs. Finally, we
introduce two more categories to enclose transaction and block dependency
exposures. Ultimately, we report twenty-two vulnerabilities over these domains
(Note: a vulnerability might be part of multiple domains). Table 2 depicts the
category and vulnerability mappings. The following subsections describe each
vulnerability in more detail.

\begin{table}[t]
        \begin{center}
            \small
            \begin{tabular}{||c|c|l||}
                \hline
                Class & No. & Vulnerability Name\\ 
                \hline
                \hline
                \multirow{8}{*}{Syntax Violations}                              & 1  & Interface violation \\ \cline{2-3}
                                                                                & 2  & Compiler version inconsistency \\ \cline{2-3}
                                                                                & 3  & Variable visibility modifiers \\ \cline{2-3}
                                                                                & 4  & Function visibility level  \\ \cline{2-3}
                                                                                & 5  & Argument validation  \\ \cline{2-3}
                                                                                & 6  & Costly coding scheme  \\ \cline{2-3}
                                                                                & 7  & Redundant Fallback Function  \\ \cline{2-3}
                                                                                & 8  & Code format/style violation  \\ \cline{1-3}
                \multirow{5}{*}{Internal Vulnerabilities}                       & 9  & Ether Freezing \\ \cline{2-3}
                                                                                & 10 & Destroybale Contract  \\ \cline{2-3}
                                                                                & 11 & Internal variable access control  \\ \cline{2-3}
                                                                                & 12 & Contract balance access control  \\ \cline{2-3}
                                                                                & 13 & Exposed secret \\ \cline{1-3}
                \multirow{6}{*}{External Vulnerabilities}                       & 14 & Reentrancy \\ \cline{2-3}
                                                                                & 15 & Denial of Service  \\ \cline{2-3}
                                                                                & 16 & Poor exception handling  \\ \cline{2-3}
                                                                                & 17 & Gasless Send  \\ \cline{2-3}
                                                                                & 18 & Non isolated external calls  \\ \cline{2-3}
                                                                                & 19 & Delegate calls \\ \cline{1-3}
                Arithmetic Vulnerabilities                                      & 20 & Integer under/over flow \\ \cline{1-3}
                \multirow{3}{*}{Gas related Vulnerabilities}                    & 21 & Denial of Service\\ \cline{2-3}
                                                                                & 22 & Integer under/over flow  \\ \cline{2-3}
                                                                                & 23 & Unbounded mass operations  \\ \cline{1-3}
                \multirow{2}{*}{Transaction related Vulnerabilities}            & 24 & Transaction ordering dependency\\ \cline{2-3}
                                                                                & 25 & Transaction state dependency  \\ \cline{1-3}
                Block related Vulnerabilities                                   & 26 & Block state dependency  \\ \cline{1-3}
            \end{tabular}
            \label{table:vulnerabilities}
            \caption{List of vulnerabilities according to their domain}
        \end{center}
\end{table}

\textbf{Interface Violations:} 
Interface violations refer to implementing particular digital assets on the
Ethereum blockchain without fully aligning with the defacto community accepted
requirements. For example, ERC-20 tokens [eth website to erc20] need to expose a
particular API interface to help third-party services communicate with their
Smart Contract flawlessly. If a developer decides to implement a non-ERC-20
compliant token, it might be considered suspicious and thus malicious.

\textbf{Compiler version inconsistency:}
Solidity source code files include a header line stating the versions of
compiler they can be complied with. A similar to Javascript notation can be used
to indicate the minor compiler version (caret character). This notation can
produce execution inconsistency in different execution environments. For this
reason, it is better to declare a stable compiler version precisely.
Nevertheless, we can argue with this proposal from Tikhomirov et al. since using
a stable compiler version might make a Smart Contract obsolete and incapable of
running on newer EVM versions.

\textbf{Variable visibility modifiers:}
Many developers migrating from traditional programming languages mistake the
\emph{private} variable modifier as not visible to others. This is a
misunderstanding since every Smart Contract state variable is visible to anyone.
The term \emph{private} means that other Smart Contract instances can not access
this variable.

\textbf{Function visibility level:}
In Solidity, a function can have three visibility levels. These are external,
internal, and public. Likewise to the previous coding pitfall, many developers
might misinterpret the meaning of these modifiers and use them wrong.

\textbf{Argument validation:}
It is a common practice to adopt for every Smart Contract function. For example,
when we receive a string of a maximum of eight characters long, we should check
that its length is valid. However, this practice can require more computational
complexity and yield more gas fees. It should be used when needed.

\textbf{Costly coding schemes:}
In Solidity, different data structures have different gas costs, but they can
achieve the same result most of the time. For instance, a developer should use
pure bytes instead of using a byte array because they have lower gas fees.
Moreover, loops a the most common coding scheme to avoid since a loop of an
unknown length comes with high execution cost.

\textbf{Redundant Fallback Function:}
Solidity supports a fallback/receive function triggered when no function
signature matches the transaction data. This function deposits the incoming
value to the contract balance when a transaction has value but no data.
Similarly, it handles any transaction that has unknown function signatures. A
fallback/receive function should be implemented only when needed; otherwise, it
is redundant.

\textbf{Code format/style violation:}
Smart Contract developers should use tidy and easy-to-read styling patterns
throughout the code.

\textbf{Ether Freezing:}
A Smart Contract, as mentioned earlier, has its balance of Ether. Different
types of applications require the user to deposit Ether to participate in a
lucky draw or an online game etc. Some Smart Contract will accept deposits, but
under specific conditions, it might lock Ether forever, acting as a black hole.
Something similar happened in 2017 with Parity wallet Smart Contract. The bug
occurred because the Parity wallet transferred funds using an external library.
That library was accidentally removed from the blockchain, and thus all Ether in
Parity wallet became inaccessible. Further, according to Nikolic et al. another
case where funds can be locked in a Smart Contract is when the contract is
removed from the blockchain, and some users continue to send Ether to it. These
Ether will be lost as well.

\textbf{Destroybale Contract:}
Smart Contracts, out of the box, give the ability to their owners or an
authorized entity to destroy them. The funds enclosed in the Smart Contract will
be returned to the owner by default. However, if an arbitrary account can
destroy the Smart Contract, it alarms a vulnerability. This abnormal code
behavior might have been maliciously constructed and helped an attacker harvest
any Ether in the Smart Contract's balance when combined with other attacks.

\textbf{Internal variable access control}
With the term internal variable access control, we refer to insecure Smart
Contract implementation that allows an adversarial entity to alter the internal
state of the Smart Contract. This kind of behavior can be combined with the
earlier mentioned Destruction vulnerability. For instance, an attacker leverages
his ability to alter the Smart Contract owner variable before the Destruction.
Besides that, attackers might straight forward access the contract's private
variables value or logic, revealing an important secret. 

\textbf{Contract balance access control}
Like internal variable access control, a Smart Contract that can be invoked to
transfer money to an arbitrary account appears questionable. We define arbitrary
accounts as addresses that have never deposited Ether into a Smart Contract but
can withdraw value from it. 

\textbf{Delegate calls}

\textbf{Reentrancy}

\textbf{Denial of Service}

\textbf{Poor exception handling}

\textbf{Gasless Send}

\textbf{Non isolated external calls}

\textbf{Integer under/over flow}

\textbf{Unbounded mass operations}

\textbf{Transaction ordering dependency}

\textbf{Transaction state dependency}

\textbf{Block state dependency}

\pagebreak

\subsection{Static Analysis}

\subsection{Dynamic Analysis}

\subsection{Symbolic Execution}

\subsection{Fuzzing}

\subsection{The Machine Learning Approach}

\section{Summary \& Conclusion}

\nocite{*}

%                Now build the reference list
\bibliographystyle{unsrt}   % The reference style
%                This is plain and unsorted, so in the order
%                they appear in the document.


\small

\bibliography{main}       % bib file(s).

\end{document}

